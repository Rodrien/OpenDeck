"""Study Session API Endpoints"""

from datetime import datetime
from typing import List
from fastapi import APIRouter, HTTPException, status

from app.schemas.study_session import (
    StartSessionRequest,
    RecordReviewRequest,
    RecordReviewResponse,
    StudySessionResponse,
    StudySessionStatsResponse,
    DueCardsCountResponse,
)
from app.schemas.card import CardResponse
from app.api.dependencies import (
    CurrentUser,
    CardRepoDepends,
    DeckRepoDepends,
    CardReviewRepoDepends,
    StudySessionRepoDepends,
)
from app.core.models import StudySession, CardReview
from app.services.spaced_repetition import SM2Algorithm

router = APIRouter(tags=["Study Sessions"])


@router.post("/study/sessions/start", response_model=StudySessionResponse, status_code=status.HTTP_201_CREATED)
async def start_study_session(
    request: StartSessionRequest,
    current_user: CurrentUser,
    deck_repo: DeckRepoDepends,
    session_repo: StudySessionRepoDepends,
) -> StudySessionResponse:
    """
    Start a new study session for a deck.

    Args:
        request: Session start request with deck_id and session_type
        current_user: Authenticated user
        deck_repo: Deck repository dependency
        session_repo: Study session repository dependency

    Returns:
        Created study session

    Raises:
        HTTPException: If deck not found or access denied
        HTTPException: If active session already exists for this deck
    """
    # Verify deck exists and user has access
    deck = deck_repo.get(request.deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    # Check for existing active session
    active_session = session_repo.get_active_session(current_user.id, request.deck_id)
    if active_session:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Active study session already exists (session_id: {active_session.id}). Please end it before starting a new one.",
        )

    # Create new study session
    session = StudySession(
        id="",  # Will be generated by repository
        user_id=current_user.id,
        deck_id=request.deck_id,
        started_at=datetime.utcnow(),
        session_type=request.session_type,
    )

    created_session = session_repo.create(session)
    return StudySessionResponse.model_validate(created_session)


@router.get("/study/decks/{deck_id}/due-cards", response_model=List[CardResponse])
async def get_due_cards(
    deck_id: str,
    current_user: CurrentUser,
    card_repo: CardRepoDepends,
    deck_repo: DeckRepoDepends,
) -> List[CardResponse]:
    """
    Get cards due for review in a deck.

    Returns cards where next_review_date is NULL or <= current time.

    Args:
        deck_id: Deck identifier
        current_user: Authenticated user
        card_repo: Card repository dependency
        deck_repo: Deck repository dependency

    Returns:
        List of cards due for review

    Raises:
        HTTPException: If deck not found or access denied
    """
    # Verify deck exists and user has access
    deck = deck_repo.get(deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    cards = card_repo.get_due_cards(deck_id, current_user.id, limit=100)
    return [CardResponse.model_validate(card) for card in cards]


@router.get("/study/decks/{deck_id}/due-count", response_model=DueCardsCountResponse)
async def get_due_cards_count(
    deck_id: str,
    current_user: CurrentUser,
    card_repo: CardRepoDepends,
    deck_repo: DeckRepoDepends,
) -> DueCardsCountResponse:
    """
    Get count of cards due for review in a deck.

    Args:
        deck_id: Deck identifier
        current_user: Authenticated user
        card_repo: Card repository dependency
        deck_repo: Deck repository dependency

    Returns:
        Card count statistics

    Raises:
        HTTPException: If deck not found or access denied
    """
    # Verify deck exists and user has access
    deck = deck_repo.get(deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    # Get all cards in deck
    all_cards = card_repo.list_by_deck(deck_id, limit=1000)

    # Count due cards
    due_cards = [card for card in all_cards if SM2Algorithm.is_due_for_review(card.next_review_date)]
    new_cards = [card for card in all_cards if card.next_review_date is None]
    learning_cards = [card for card in all_cards if card.is_learning and card.next_review_date is not None]

    return DueCardsCountResponse(
        deck_id=deck_id,
        total_cards=len(all_cards),
        due_cards=len(due_cards),
        new_cards=len(new_cards),
        learning_cards=len(learning_cards),
    )


@router.post("/study/sessions/{session_id}/review", response_model=RecordReviewResponse)
async def record_card_review(
    session_id: str,
    request: RecordReviewRequest,
    current_user: CurrentUser,
    card_repo: CardRepoDepends,
    session_repo: StudySessionRepoDepends,
    review_repo: CardReviewRepoDepends,
) -> RecordReviewResponse:
    """
    Record a card review and update SM-2 parameters.

    Applies the SuperMemo 2 algorithm to calculate next review interval
    and updates the card's spaced repetition parameters.

    Args:
        session_id: Study session identifier
        request: Review request with card_id and quality rating
        current_user: Authenticated user
        card_repo: Card repository dependency
        session_repo: Study session repository dependency
        review_repo: Card review repository dependency

    Returns:
        Next review schedule information

    Raises:
        HTTPException: If session not found or doesn't belong to user
        HTTPException: If card not found
    """
    # Verify session exists and belongs to user
    session = session_repo.get(session_id)
    if not session or session.user_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Study session not found",
        )

    if session.ended_at is not None:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot record review for an ended session",
        )

    # Get card
    card = card_repo.get(request.card_id)
    if not card:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Card not found",
        )

    # Calculate new SM-2 values
    new_ease, new_interval, new_reps = SM2Algorithm.calculate_next_interval(
        quality=request.quality,
        ease_factor=card.ease_factor,
        interval_days=card.interval_days,
        repetitions=card.repetitions,
    )

    next_review = SM2Algorithm.get_next_review_date(new_interval)

    # Update card with new spaced repetition parameters
    card_repo.update_review_status(
        card_id=card.id,
        ease_factor=new_ease,
        interval_days=new_interval,
        repetitions=new_reps,
        next_review_date=next_review,
        is_learning=(new_reps == 0),
    )

    # Record review
    review = CardReview(
        id="",  # Will be generated by repository
        card_id=request.card_id,
        user_id=current_user.id,
        review_date=datetime.utcnow(),
        quality=request.quality,
        ease_factor=new_ease,
        interval_days=new_interval,
        repetitions=new_reps,
    )
    review_repo.create(review)

    # Update session statistics
    session.record_review(correct=(request.quality >= 3))
    session_repo.update(session)

    return RecordReviewResponse(
        next_interval_days=new_interval,
        next_review_date=next_review,
        ease_factor=new_ease,
        repetitions=new_reps,
        is_learning=(new_reps == 0),
    )


@router.post("/study/sessions/{session_id}/end", response_model=StudySessionStatsResponse)
async def end_study_session(
    session_id: str,
    current_user: CurrentUser,
    session_repo: StudySessionRepoDepends,
    card_repo: CardRepoDepends,
) -> StudySessionStatsResponse:
    """
    End a study session and return statistics.

    Args:
        session_id: Study session identifier
        current_user: Authenticated user
        session_repo: Study session repository dependency
        card_repo: Card repository dependency

    Returns:
        Session statistics including accuracy and remaining cards

    Raises:
        HTTPException: If session not found or doesn't belong to user
        HTTPException: If session is already ended
    """
    # Verify session exists and belongs to user
    session = session_repo.get(session_id)
    if not session or session.user_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Study session not found",
        )

    if session.ended_at is not None:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Session is already ended",
        )

    # End the session
    session.end_session()
    updated_session = session_repo.update(session)

    # Calculate accuracy
    accuracy = 0.0
    if updated_session.cards_reviewed > 0:
        accuracy = (updated_session.cards_correct / updated_session.cards_reviewed) * 100

    # Get remaining due cards count
    remaining_cards = card_repo.get_due_cards(
        deck_id=updated_session.deck_id,
        user_id=current_user.id,
        limit=1000,
    )

    return StudySessionStatsResponse(
        session=StudySessionResponse.model_validate(updated_session),
        accuracy=round(accuracy, 2),
        cards_remaining=len(remaining_cards),
    )


@router.get("/study/sessions", response_model=List[StudySessionResponse])
async def list_study_sessions(
    current_user: CurrentUser,
    session_repo: StudySessionRepoDepends,
    deck_id: str | None = None,
) -> List[StudySessionResponse]:
    """
    List study sessions for the current user.

    Args:
        current_user: Authenticated user
        session_repo: Study session repository dependency
        deck_id: Optional deck filter

    Returns:
        List of study sessions
    """
    sessions = session_repo.get_by_user(
        user_id=current_user.id,
        deck_id=deck_id,
        limit=100,
    )
    return [StudySessionResponse.model_validate(session) for session in sessions]


@router.get("/study/sessions/{session_id}", response_model=StudySessionResponse)
async def get_study_session(
    session_id: str,
    current_user: CurrentUser,
    session_repo: StudySessionRepoDepends,
) -> StudySessionResponse:
    """
    Get a single study session.

    Args:
        session_id: Study session identifier
        current_user: Authenticated user
        session_repo: Study session repository dependency

    Returns:
        Study session details

    Raises:
        HTTPException: If session not found or doesn't belong to user
    """
    session = session_repo.get(session_id)
    if not session or session.user_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Study session not found",
        )

    return StudySessionResponse.model_validate(session)
