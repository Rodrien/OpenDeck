"""Study Session API Endpoints"""

from datetime import datetime
from typing import List
from fastapi import APIRouter, HTTPException, status

from app.schemas.study_session import (
    StartSessionRequest,
    RecordReviewRequest,
    RecordReviewResponse,
    StudySessionResponse,
    StudySessionStatsResponse,
    DueCardsCountResponse,
    StudyStatsResponse,
)
from app.schemas.card import CardResponse
from app.api.dependencies import (
    CurrentUser,
    CardRepoDepends,
    DeckRepoDepends,
    CardReviewRepoDepends,
    StudySessionRepoDepends,
)
from app.core.models import StudySession, CardReview
from app.services.spaced_repetition import SM2Algorithm

router = APIRouter(tags=["Study Sessions"])


@router.post("/study/sessions", response_model=StudySessionResponse, status_code=status.HTTP_201_CREATED)
async def start_study_session(
    request: StartSessionRequest,
    current_user: CurrentUser,
    deck_repo: DeckRepoDepends,
    session_repo: StudySessionRepoDepends,
    card_repo: CardRepoDepends,
) -> StudySessionResponse:
    """
    Start a new study session for a deck.

    Args:
        request: Session start request with deck_id and session_type
        current_user: Authenticated user
        deck_repo: Deck repository dependency
        session_repo: Study session repository dependency
        card_repo: Card repository dependency

    Returns:
        Created study session with card IDs

    Raises:
        HTTPException: If deck not found or access denied
        HTTPException: If active session already exists for this deck
    """
    # Verify deck exists and user has access
    deck = deck_repo.get(request.deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    # Check for existing active session
    active_session = session_repo.get_active_session(current_user.id, request.deck_id)
    if active_session:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Active study session already exists (session_id: {active_session.id}). Please end it before starting a new one.",
        )

    # Create new study session
    session = StudySession(
        id="",  # Will be generated by repository
        user_id=current_user.id,
        deck_id=request.deck_id,
        started_at=datetime.utcnow(),
        session_type=request.session_type,
    )

    created_session = session_repo.create(session)

    # Get due cards for this session
    due_cards = card_repo.get_due_cards(request.deck_id, current_user.id, limit=100)
    card_ids = [card.id for card in due_cards]

    # Convert to response with additional fields
    response_data = {
        "id": created_session.id,
        "user_id": created_session.user_id,
        "deck_id": created_session.deck_id,
        "started_at": created_session.started_at,
        "ended_at": created_session.ended_at,
        "cards_reviewed": created_session.cards_reviewed,
        "cards_correct": created_session.cards_correct,
        "cards_incorrect": created_session.cards_incorrect,
        "total_time_seconds": created_session.total_duration_seconds,
        "session_type": created_session.session_type,
        "card_ids": card_ids,
        "reviews": [],
        "current_card_index": 0,
        "is_completed": False,
    }

    return StudySessionResponse(**response_data)


@router.get("/study/sessions/active/{deck_id}", response_model=StudySessionResponse | None)
async def get_active_session(
    deck_id: str,
    current_user: CurrentUser,
    deck_repo: DeckRepoDepends,
    session_repo: StudySessionRepoDepends,
    card_repo: CardRepoDepends,
) -> StudySessionResponse | None:
    """
    Get active study session for a deck.

    Returns the active (not ended) session for the specified deck, or null if none exists.

    Args:
        deck_id: Deck identifier
        current_user: Authenticated user
        deck_repo: Deck repository dependency
        session_repo: Study session repository dependency
        card_repo: Card repository dependency

    Returns:
        Active study session or None

    Raises:
        HTTPException: If deck not found or access denied
    """
    # Verify deck exists and user has access
    deck = deck_repo.get(deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    # Get active session
    active_session = session_repo.get_active_session(current_user.id, deck_id)
    if not active_session:
        return None

    # Get due cards for this session
    due_cards = card_repo.get_due_cards(deck_id, current_user.id, limit=100)
    card_ids = [card.id for card in due_cards]

    # Convert to response with additional fields
    response_data = {
        "id": active_session.id,
        "user_id": active_session.user_id,
        "deck_id": active_session.deck_id,
        "started_at": active_session.started_at,
        "ended_at": active_session.ended_at,
        "cards_reviewed": active_session.cards_reviewed,
        "cards_correct": active_session.cards_correct,
        "cards_incorrect": active_session.cards_incorrect,
        "total_time_seconds": active_session.total_duration_seconds,
        "session_type": active_session.session_type,
        "card_ids": card_ids,
        "reviews": [],
        "current_card_index": active_session.cards_reviewed,
        "is_completed": active_session.ended_at is not None,
    }

    return StudySessionResponse(**response_data)


@router.get("/study/decks/{deck_id}/due", response_model=List[CardResponse])
async def get_due_cards(
    deck_id: str,
    current_user: CurrentUser,
    card_repo: CardRepoDepends,
    deck_repo: DeckRepoDepends,
) -> List[CardResponse]:
    """
    Get cards due for review in a deck.

    Returns cards where next_review_date is NULL or <= current time.

    Args:
        deck_id: Deck identifier
        current_user: Authenticated user
        card_repo: Card repository dependency
        deck_repo: Deck repository dependency

    Returns:
        List of cards due for review

    Raises:
        HTTPException: If deck not found or access denied
    """
    # Verify deck exists and user has access
    deck = deck_repo.get(deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    cards = card_repo.get_due_cards(deck_id, current_user.id, limit=100)
    return [CardResponse.model_validate(card) for card in cards]


@router.get("/study/decks/{deck_id}/due-count", response_model=DueCardsCountResponse)
async def get_due_cards_count(
    deck_id: str,
    current_user: CurrentUser,
    card_repo: CardRepoDepends,
    deck_repo: DeckRepoDepends,
) -> DueCardsCountResponse:
    """
    Get count of cards due for review in a deck.

    Uses efficient SQL queries to count cards by status without loading all cards into memory.

    Args:
        deck_id: Deck identifier
        current_user: Authenticated user
        card_repo: Card repository dependency
        deck_repo: Deck repository dependency

    Returns:
        Card count statistics

    Raises:
        HTTPException: If deck not found or access denied
    """
    # Verify deck exists and user has access
    deck = deck_repo.get(deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    # Get statistics using efficient SQL queries
    stats = card_repo.get_deck_stats(deck_id, current_user.id)

    return DueCardsCountResponse(
        deck_id=deck_id,
        total_cards=stats["total_cards"],
        due_cards=stats["due_cards"],
        new_cards=stats["new_cards"],
        learning_cards=stats["learning_cards"],
    )


@router.get("/study/decks/{deck_id}/stats", response_model=StudyStatsResponse)
async def get_deck_stats(
    deck_id: str,
    current_user: CurrentUser,
    card_repo: CardRepoDepends,
    deck_repo: DeckRepoDepends,
) -> StudyStatsResponse:
    """
    Get study statistics for a deck.

    Returns comprehensive statistics including card counts by status,
    average ease factor, completion rate, and next review date.

    Args:
        deck_id: Deck identifier
        current_user: Authenticated user
        card_repo: Card repository dependency
        deck_repo: Deck repository dependency

    Returns:
        Deck study statistics

    Raises:
        HTTPException: If deck not found or access denied
    """
    # Verify deck exists and user has access
    deck = deck_repo.get(deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    # Get statistics from repository
    stats = card_repo.get_deck_stats(deck_id, current_user.id)

    return StudyStatsResponse(**stats)


@router.post("/study/sessions/{session_id}/reviews", response_model=RecordReviewResponse)
async def record_card_review(
    session_id: str,
    request: RecordReviewRequest,
    current_user: CurrentUser,
    card_repo: CardRepoDepends,
    session_repo: StudySessionRepoDepends,
    review_repo: CardReviewRepoDepends,
) -> RecordReviewResponse:
    """
    Record a card review and update SM-2 parameters.

    Applies the SuperMemo 2 algorithm to calculate next review interval
    and updates the card's spaced repetition parameters.

    Args:
        session_id: Study session identifier
        request: Review request with card_id and quality rating
        current_user: Authenticated user
        card_repo: Card repository dependency
        session_repo: Study session repository dependency
        review_repo: Card review repository dependency

    Returns:
        Next review schedule information

    Raises:
        HTTPException: If session not found or doesn't belong to user
        HTTPException: If card not found
    """
    # Verify session exists and belongs to user
    session = session_repo.get(session_id)
    if not session or session.user_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Study session not found",
        )

    if session.ended_at is not None:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot record review for an ended session",
        )

    # Get card
    card = card_repo.get(request.card_id)
    if not card:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Card not found",
        )

    # SECURITY: Verify card belongs to the deck in the session
    if card.deck_id != session.deck_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Card does not belong to the deck in this study session",
        )

    # Calculate new SM-2 values
    new_ease, new_interval, new_reps = SM2Algorithm.calculate_next_interval(
        quality=request.quality,
        ease_factor=card.ease_factor,
        interval_days=card.interval_days,
        repetitions=card.repetitions,
    )

    next_review = SM2Algorithm.get_next_review_date(new_interval)

    # Update card with new spaced repetition parameters
    card_repo.update_review_status(
        card_id=card.id,
        ease_factor=new_ease,
        interval_days=new_interval,
        repetitions=new_reps,
        next_review_date=next_review,
        is_learning=(new_reps == 0),
    )

    # Record review
    review = CardReview(
        id="",  # Will be generated by repository
        card_id=request.card_id,
        user_id=current_user.id,
        review_date=datetime.utcnow(),
        quality=request.quality,
        ease_factor=new_ease,
        interval_days=new_interval,
        repetitions=new_reps,
    )
    review_repo.create(review)

    # Update session statistics
    session.record_review(correct=(request.quality >= 3))
    session_repo.update(session)

    return RecordReviewResponse(
        next_interval_days=new_interval,
        next_review_date=next_review,
        ease_factor=new_ease,
        repetitions=new_reps,
        is_learning=(new_reps == 0),
    )


@router.post("/study/sessions/{session_id}/complete", response_model=StudySessionStatsResponse)
async def end_study_session(
    session_id: str,
    current_user: CurrentUser,
    session_repo: StudySessionRepoDepends,
    card_repo: CardRepoDepends,
) -> StudySessionStatsResponse:
    """
    End a study session and return statistics.

    Args:
        session_id: Study session identifier
        current_user: Authenticated user
        session_repo: Study session repository dependency
        card_repo: Card repository dependency

    Returns:
        Session statistics including accuracy and remaining cards

    Raises:
        HTTPException: If session not found or doesn't belong to user
        HTTPException: If session is already ended
    """
    # Verify session exists and belongs to user
    session = session_repo.get(session_id)
    if not session or session.user_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Study session not found",
        )

    if session.ended_at is not None:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Session is already ended",
        )

    # End the session
    session.end_session()
    updated_session = session_repo.update(session)

    # Calculate accuracy
    accuracy = 0.0
    if updated_session.cards_reviewed > 0:
        accuracy = (updated_session.cards_correct / updated_session.cards_reviewed) * 100

    # Get remaining due cards count
    remaining_cards = card_repo.get_due_cards(
        deck_id=updated_session.deck_id,
        user_id=current_user.id,
        limit=1000,
    )

    # Convert session to response with additional fields
    session_data = {
        "id": updated_session.id,
        "user_id": updated_session.user_id,
        "deck_id": updated_session.deck_id,
        "started_at": updated_session.started_at,
        "ended_at": updated_session.ended_at,
        "cards_reviewed": updated_session.cards_reviewed,
        "cards_correct": updated_session.cards_correct,
        "cards_incorrect": updated_session.cards_incorrect,
        "total_time_seconds": updated_session.total_duration_seconds,
        "session_type": updated_session.session_type,
        "card_ids": [],
        "reviews": [],
        "current_card_index": updated_session.cards_reviewed,
        "is_completed": True,
    }

    return StudySessionStatsResponse(
        session=StudySessionResponse(**session_data),
        accuracy=round(accuracy, 2),
        cards_remaining=len(remaining_cards),
    )


@router.get("/study/sessions", response_model=List[StudySessionResponse])
async def list_study_sessions(
    current_user: CurrentUser,
    session_repo: StudySessionRepoDepends,
    deck_id: str | None = None,
) -> List[StudySessionResponse]:
    """
    List study sessions for the current user.

    Args:
        current_user: Authenticated user
        session_repo: Study session repository dependency
        deck_id: Optional deck filter

    Returns:
        List of study sessions
    """
    sessions = session_repo.get_by_user(
        user_id=current_user.id,
        deck_id=deck_id,
        limit=100,
    )

    # Convert sessions to response format with additional fields
    result = []
    for session in sessions:
        session_data = {
            "id": session.id,
            "user_id": session.user_id,
            "deck_id": session.deck_id,
            "started_at": session.started_at,
            "ended_at": session.ended_at,
            "cards_reviewed": session.cards_reviewed,
            "cards_correct": session.cards_correct,
            "cards_incorrect": session.cards_incorrect,
            "total_time_seconds": session.total_duration_seconds,
            "session_type": session.session_type,
            "card_ids": [],
            "reviews": [],
            "current_card_index": session.cards_reviewed,
            "is_completed": session.ended_at is not None,
        }
        result.append(StudySessionResponse(**session_data))

    return result


@router.get("/study/sessions/{session_id}", response_model=StudySessionResponse)
async def get_study_session(
    session_id: str,
    current_user: CurrentUser,
    session_repo: StudySessionRepoDepends,
) -> StudySessionResponse:
    """
    Get a single study session.

    Args:
        session_id: Study session identifier
        current_user: Authenticated user
        session_repo: Study session repository dependency

    Returns:
        Study session details

    Raises:
        HTTPException: If session not found or doesn't belong to user
    """
    session = session_repo.get(session_id)
    if not session or session.user_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Study session not found",
        )

    # Convert to response format with additional fields
    session_data = {
        "id": session.id,
        "user_id": session.user_id,
        "deck_id": session.deck_id,
        "started_at": session.started_at,
        "ended_at": session.ended_at,
        "cards_reviewed": session.cards_reviewed,
        "cards_correct": session.cards_correct,
        "cards_incorrect": session.cards_incorrect,
        "total_time_seconds": session.total_duration_seconds,
        "session_type": session.session_type,
        "card_ids": [],
        "reviews": [],
        "current_card_index": session.cards_reviewed,
        "is_completed": session.ended_at is not None,
    }

    return StudySessionResponse(**session_data)


@router.get("/study/cards/{card_id}", response_model=CardResponse)
async def get_card_with_metadata(
    card_id: str,
    current_user: CurrentUser,
    card_repo: CardRepoDepends,
    deck_repo: DeckRepoDepends,
) -> CardResponse:
    """
    Get a card with spaced repetition metadata.

    Args:
        card_id: Card identifier
        current_user: Authenticated user
        card_repo: Card repository dependency
        deck_repo: Deck repository dependency

    Returns:
        Card with full spaced repetition metadata

    Raises:
        HTTPException: If card not found or access denied
    """
    # Get card
    card = card_repo.get(card_id)
    if not card:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Card not found",
        )

    # Verify user has access to the deck
    deck = deck_repo.get(card.deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied",
        )

    return CardResponse.model_validate(card)


@router.post("/study/cards/{card_id}/reset", status_code=status.HTTP_204_NO_CONTENT)
async def reset_card_progress(
    card_id: str,
    current_user: CurrentUser,
    card_repo: CardRepoDepends,
    deck_repo: DeckRepoDepends,
) -> None:
    """
    Reset a card's spaced repetition progress.

    Sets the card back to default SM-2 values:
    - ease_factor: 2.5
    - interval_days: 0
    - repetitions: 0
    - next_review_date: None
    - is_learning: True

    Args:
        card_id: Card identifier
        current_user: Authenticated user
        card_repo: Card repository dependency
        deck_repo: Deck repository dependency

    Raises:
        HTTPException: If card not found or access denied
    """
    # Get card
    card = card_repo.get(card_id)
    if not card:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Card not found",
        )

    # Verify user has access to the deck
    deck = deck_repo.get(card.deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied",
        )

    # Reset card progress
    card_repo.reset_card_progress(card_id)


@router.post("/study/decks/{deck_id}/reset", status_code=status.HTTP_204_NO_CONTENT)
async def reset_deck_progress(
    deck_id: str,
    current_user: CurrentUser,
    card_repo: CardRepoDepends,
    deck_repo: DeckRepoDepends,
) -> None:
    """
    Reset all cards' spaced repetition progress in a deck.

    Sets all cards in the deck back to default SM-2 values:
    - ease_factor: 2.5
    - interval_days: 0
    - repetitions: 0
    - next_review_date: None
    - is_learning: True

    Args:
        deck_id: Deck identifier
        current_user: Authenticated user
        card_repo: Card repository dependency
        deck_repo: Deck repository dependency

    Raises:
        HTTPException: If deck not found or access denied
    """
    # Verify deck exists and user has access
    deck = deck_repo.get(deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    # Reset all cards in deck
    card_repo.reset_deck_progress(deck_id, current_user.id)
