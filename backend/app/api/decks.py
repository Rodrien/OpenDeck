"""Deck Management API Endpoints"""

from typing import Optional
from fastapi import APIRouter, HTTPException, status, Query
from app.schemas.deck import DeckCreate, DeckUpdate, DeckResponse, DeckListResponse
from app.schemas.topic import TopicResponse
from app.api.dependencies import CurrentUser, CurrentUserOptional, DeckRepoDepends, TopicRepoDepends
from app.core.models import Deck, DifficultyLevel

router = APIRouter(prefix="/decks", tags=["Decks"])


@router.get("", response_model=DeckListResponse)
async def list_decks(
    current_user: CurrentUserOptional,
    deck_repo: DeckRepoDepends,
    topic_repo: TopicRepoDepends,
    category: Optional[str] = Query(None, description="Filter by category"),
    difficulty: Optional[DifficultyLevel] = Query(None, description="Filter by difficulty"),
    topic_id: Optional[str] = Query(None, description="Filter by topic"),
    limit: int = Query(100, ge=1, le=100, description="Maximum number of results"),
    offset: int = Query(0, ge=0, description="Number of results to skip"),
) -> DeckListResponse:
    """
    List user's decks with optional filters.

    NOTE: For Phase 1 development, authentication is optional.
    If no user is authenticated, returns the first user's decks.
    This should be replaced with proper authentication before production.

    Args:
        current_user: Authenticated user (optional in development)
        deck_repo: Deck repository dependency
        topic_repo: Topic repository dependency
        category: Optional category filter
        difficulty: Optional difficulty filter
        topic_id: Optional topic filter
        limit: Maximum number of results (1-100)
        offset: Pagination offset

    Returns:
        Paginated list of decks
    """
    if not current_user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="No users found in the system",
        )

    decks = deck_repo.list(
        user_id=current_user.id,
        category=category,
        difficulty=difficulty.value if difficulty else None,
        topic_id=topic_id,
        limit=limit,
        offset=offset,
    )

    # Enrich decks with topics
    deck_responses = []
    for deck in decks:
        topics = topic_repo.get_topics_for_deck(deck.id)
        deck_dict = deck.__dict__.copy()
        deck_dict['topics'] = [TopicResponse.model_validate(topic) for topic in topics]
        deck_responses.append(DeckResponse.model_validate(deck_dict))

    # For total count, we'd need a count query in a real implementation
    # For Phase 1, we'll use the returned count
    total = len(decks) + offset

    return DeckListResponse(
        items=deck_responses,
        total=total,
        limit=limit,
        offset=offset,
    )


@router.get("/{deck_id}", response_model=DeckResponse)
async def get_deck(
    deck_id: str,
    current_user: CurrentUserOptional,
    deck_repo: DeckRepoDepends,
    topic_repo: TopicRepoDepends,
) -> DeckResponse:
    """
    Get a single deck by ID.

    NOTE: For Phase 1 development, authentication is optional.

    Args:
        deck_id: Deck identifier
        current_user: Authenticated user (optional in development)
        deck_repo: Deck repository dependency
        topic_repo: Topic repository dependency

    Returns:
        Deck details

    Raises:
        HTTPException: If deck not found or access denied
    """
    if not current_user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="No users found in the system",
        )

    deck = deck_repo.get(deck_id, current_user.id)

    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    # Enrich with topics
    topics = topic_repo.get_topics_for_deck(deck.id)
    deck_dict = deck.__dict__.copy()
    deck_dict['topics'] = [TopicResponse.model_validate(topic) for topic in topics]

    return DeckResponse.model_validate(deck_dict)


@router.post("", response_model=DeckResponse, status_code=status.HTTP_201_CREATED)
async def create_deck(
    deck_data: DeckCreate,
    current_user: CurrentUser,
    deck_repo: DeckRepoDepends,
) -> DeckResponse:
    """
    Create a new deck.

    Args:
        deck_data: Deck creation data
        current_user: Authenticated user
        deck_repo: Deck repository dependency

    Returns:
        Created deck
    """
    deck = Deck(
        id="",  # Will be generated by repository
        user_id=current_user.id,
        title=deck_data.title,
        description=deck_data.description,
        category=deck_data.category,
        difficulty=deck_data.difficulty,
        card_count=0,
    )

    created_deck = deck_repo.create(deck)
    return DeckResponse.model_validate(created_deck)


@router.put("/{deck_id}", response_model=DeckResponse)
async def update_deck(
    deck_id: str,
    deck_data: DeckUpdate,
    current_user: CurrentUser,
    deck_repo: DeckRepoDepends,
) -> DeckResponse:
    """
    Update an existing deck.

    Args:
        deck_id: Deck identifier
        deck_data: Deck update data
        current_user: Authenticated user
        deck_repo: Deck repository dependency

    Returns:
        Updated deck

    Raises:
        HTTPException: If deck not found or access denied
    """
    deck = deck_repo.get(deck_id, current_user.id)

    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    # Update only provided fields
    if deck_data.title is not None:
        deck.title = deck_data.title
    if deck_data.description is not None:
        deck.description = deck_data.description
    if deck_data.category is not None:
        deck.category = deck_data.category
    if deck_data.difficulty is not None:
        deck.difficulty = deck_data.difficulty

    updated_deck = deck_repo.update(deck)
    return DeckResponse.model_validate(updated_deck)


@router.delete("/{deck_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_deck(
    deck_id: str,
    current_user: CurrentUser,
    deck_repo: DeckRepoDepends,
) -> None:
    """
    Delete a deck.

    Args:
        deck_id: Deck identifier
        current_user: Authenticated user
        deck_repo: Deck repository dependency

    Raises:
        HTTPException: If deck not found or access denied
    """
    deck = deck_repo.get(deck_id, current_user.id)

    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    deck_repo.delete(deck_id, current_user.id)
