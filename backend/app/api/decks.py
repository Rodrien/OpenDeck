"""Deck Management API Endpoints"""

from typing import Optional
from fastapi import APIRouter, HTTPException, status, Query
from app.schemas.deck import DeckCreate, DeckUpdate, DeckResponse, DeckListResponse
from app.api.dependencies import CurrentUser, DeckRepoDepends
from app.core.models import Deck, DifficultyLevel

router = APIRouter(prefix="/decks", tags=["Decks"])


@router.get("", response_model=DeckListResponse)
async def list_decks(
    current_user: CurrentUser,
    deck_repo: DeckRepoDepends,
    category: Optional[str] = Query(None, description="Filter by category"),
    difficulty: Optional[DifficultyLevel] = Query(None, description="Filter by difficulty"),
    limit: int = Query(100, ge=1, le=100, description="Maximum number of results"),
    offset: int = Query(0, ge=0, description="Number of results to skip"),
) -> DeckListResponse:
    """
    List user's decks with optional filters.

    Args:
        current_user: Authenticated user
        deck_repo: Deck repository dependency
        category: Optional category filter
        difficulty: Optional difficulty filter
        limit: Maximum number of results (1-100)
        offset: Pagination offset

    Returns:
        Paginated list of decks
    """
    decks = deck_repo.list(
        user_id=current_user.id,
        category=category,
        difficulty=difficulty.value if difficulty else None,
        limit=limit,
        offset=offset,
    )

    # For total count, we'd need a count query in a real implementation
    # For Phase 1, we'll use the returned count
    total = len(decks) + offset

    return DeckListResponse(
        items=[DeckResponse.model_validate(deck) for deck in decks],
        total=total,
        limit=limit,
        offset=offset,
    )


@router.get("/{deck_id}", response_model=DeckResponse)
async def get_deck(
    deck_id: str,
    current_user: CurrentUser,
    deck_repo: DeckRepoDepends,
) -> DeckResponse:
    """
    Get a single deck by ID.

    Args:
        deck_id: Deck identifier
        current_user: Authenticated user
        deck_repo: Deck repository dependency

    Returns:
        Deck details

    Raises:
        HTTPException: If deck not found or access denied
    """
    deck = deck_repo.get(deck_id, current_user.id)

    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    return DeckResponse.model_validate(deck)


@router.post("", response_model=DeckResponse, status_code=status.HTTP_201_CREATED)
async def create_deck(
    deck_data: DeckCreate,
    current_user: CurrentUser,
    deck_repo: DeckRepoDepends,
) -> DeckResponse:
    """
    Create a new deck.

    Args:
        deck_data: Deck creation data
        current_user: Authenticated user
        deck_repo: Deck repository dependency

    Returns:
        Created deck
    """
    deck = Deck(
        id="",  # Will be generated by repository
        user_id=current_user.id,
        title=deck_data.title,
        description=deck_data.description,
        category=deck_data.category,
        difficulty=deck_data.difficulty,
        card_count=0,
    )

    created_deck = deck_repo.create(deck)
    return DeckResponse.model_validate(created_deck)


@router.put("/{deck_id}", response_model=DeckResponse)
async def update_deck(
    deck_id: str,
    deck_data: DeckUpdate,
    current_user: CurrentUser,
    deck_repo: DeckRepoDepends,
) -> DeckResponse:
    """
    Update an existing deck.

    Args:
        deck_id: Deck identifier
        deck_data: Deck update data
        current_user: Authenticated user
        deck_repo: Deck repository dependency

    Returns:
        Updated deck

    Raises:
        HTTPException: If deck not found or access denied
    """
    deck = deck_repo.get(deck_id, current_user.id)

    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    # Update only provided fields
    if deck_data.title is not None:
        deck.title = deck_data.title
    if deck_data.description is not None:
        deck.description = deck_data.description
    if deck_data.category is not None:
        deck.category = deck_data.category
    if deck_data.difficulty is not None:
        deck.difficulty = deck_data.difficulty

    updated_deck = deck_repo.update(deck)
    return DeckResponse.model_validate(updated_deck)


@router.delete("/{deck_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_deck(
    deck_id: str,
    current_user: CurrentUser,
    deck_repo: DeckRepoDepends,
) -> None:
    """
    Delete a deck.

    Args:
        deck_id: Deck identifier
        current_user: Authenticated user
        deck_repo: Deck repository dependency

    Raises:
        HTTPException: If deck not found or access denied
    """
    deck = deck_repo.get(deck_id, current_user.id)

    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    deck_repo.delete(deck_id, current_user.id)
