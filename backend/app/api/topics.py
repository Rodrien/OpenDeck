"""Topic Management API Endpoints"""

from fastapi import APIRouter, HTTPException, status, Query
from app.schemas.topic import (
    TopicCreate,
    TopicUpdate,
    TopicResponse,
    TopicListResponse,
    TopicAssociation,
)
from app.api.dependencies import TopicRepoDepends, DeckRepoDepends, CardRepoDepends, CurrentUser
from app.core.models import Topic

router = APIRouter(prefix="/topics", tags=["Topics"])


@router.get("", response_model=TopicListResponse)
async def list_topics(
    topic_repo: TopicRepoDepends,
    limit: int = Query(100, ge=1, le=100, description="Maximum number of results"),
    offset: int = Query(0, ge=0, description="Number of results to skip"),
) -> TopicListResponse:
    """
    List all topics.

    Args:
        topic_repo: Topic repository dependency
        limit: Maximum number of results (1-100)
        offset: Pagination offset

    Returns:
        Paginated list of topics
    """
    topics = topic_repo.list(limit=limit, offset=offset)

    # For total count, we'd need a count query in a real implementation
    # For now, we'll use the returned count
    total = len(topics) + offset

    return TopicListResponse(
        items=[TopicResponse.model_validate(topic) for topic in topics],
        total=total,
        limit=limit,
        offset=offset,
    )


@router.get("/{topic_id}", response_model=TopicResponse)
async def get_topic(
    topic_id: str,
    topic_repo: TopicRepoDepends,
) -> TopicResponse:
    """
    Get a single topic by ID.

    Args:
        topic_id: Topic identifier
        topic_repo: Topic repository dependency

    Returns:
        Topic details

    Raises:
        HTTPException: If topic not found
    """
    topic = topic_repo.get(topic_id)

    if not topic:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Topic not found",
        )

    return TopicResponse.model_validate(topic)


@router.post("", response_model=TopicResponse, status_code=status.HTTP_201_CREATED)
async def create_topic(
    topic_data: TopicCreate,
    topic_repo: TopicRepoDepends,
) -> TopicResponse:
    """
    Create a new topic.

    Args:
        topic_data: Topic creation data
        topic_repo: Topic repository dependency

    Returns:
        Created topic

    Raises:
        HTTPException: If topic with same name already exists
    """
    # Check if topic with same name exists
    existing_topic = topic_repo.get_by_name(topic_data.name)
    if existing_topic:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Topic with name '{topic_data.name}' already exists",
        )

    topic = Topic(
        id="",  # Will be generated by repository
        name=topic_data.name,
        description=topic_data.description,
    )

    created_topic = topic_repo.create(topic)
    return TopicResponse.model_validate(created_topic)


@router.put("/{topic_id}", response_model=TopicResponse)
async def update_topic(
    topic_id: str,
    topic_data: TopicUpdate,
    topic_repo: TopicRepoDepends,
) -> TopicResponse:
    """
    Update an existing topic.

    Args:
        topic_id: Topic identifier
        topic_data: Topic update data
        topic_repo: Topic repository dependency

    Returns:
        Updated topic

    Raises:
        HTTPException: If topic not found or name conflict
    """
    topic = topic_repo.get(topic_id)

    if not topic:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Topic not found",
        )

    # Check for name conflicts if name is being updated
    if topic_data.name is not None and topic_data.name != topic.name:
        existing_topic = topic_repo.get_by_name(topic_data.name)
        if existing_topic:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail=f"Topic with name '{topic_data.name}' already exists",
            )

    # Update only provided fields
    if topic_data.name is not None:
        topic.name = topic_data.name
    if topic_data.description is not None:
        topic.description = topic_data.description

    updated_topic = topic_repo.update(topic)
    return TopicResponse.model_validate(updated_topic)


@router.delete("/{topic_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_topic(
    topic_id: str,
    topic_repo: TopicRepoDepends,
) -> None:
    """
    Delete a topic.

    This will also remove all associations between this topic and decks/cards.

    Args:
        topic_id: Topic identifier
        topic_repo: Topic repository dependency

    Raises:
        HTTPException: If topic not found
    """
    topic = topic_repo.get(topic_id)

    if not topic:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Topic not found",
        )

    topic_repo.delete(topic_id)


# Deck-Topic Association Endpoints


@router.post("/decks/{deck_id}/topics", status_code=status.HTTP_204_NO_CONTENT)
async def associate_topic_with_deck(
    deck_id: str,
    association: TopicAssociation,
    current_user: CurrentUser,
    deck_repo: DeckRepoDepends,
    topic_repo: TopicRepoDepends,
) -> None:
    """
    Associate a topic with a deck.

    Args:
        deck_id: Deck identifier
        association: Topic association data
        current_user: Authenticated user
        deck_repo: Deck repository dependency
        topic_repo: Topic repository dependency

    Raises:
        HTTPException: If deck or topic not found, or access denied
    """
    # Verify deck exists and user has access
    deck = deck_repo.get(deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    # Verify topic exists
    topic = topic_repo.get(association.topic_id)
    if not topic:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Topic not found",
        )

    topic_repo.associate_deck_topic(deck_id, association.topic_id)


@router.delete("/decks/{deck_id}/topics/{topic_id}", status_code=status.HTTP_204_NO_CONTENT)
async def dissociate_topic_from_deck(
    deck_id: str,
    topic_id: str,
    current_user: CurrentUser,
    deck_repo: DeckRepoDepends,
    topic_repo: TopicRepoDepends,
) -> None:
    """
    Remove topic association from a deck.

    Args:
        deck_id: Deck identifier
        topic_id: Topic identifier
        current_user: Authenticated user
        deck_repo: Deck repository dependency
        topic_repo: Topic repository dependency

    Raises:
        HTTPException: If deck or topic not found, or access denied
    """
    # Verify deck exists and user has access
    deck = deck_repo.get(deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Deck not found",
        )

    # Verify topic exists
    topic = topic_repo.get(topic_id)
    if not topic:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Topic not found",
        )

    topic_repo.dissociate_deck_topic(deck_id, topic_id)


# Card-Topic Association Endpoints


@router.post("/cards/{card_id}/topics", status_code=status.HTTP_204_NO_CONTENT)
async def associate_topic_with_card(
    card_id: str,
    association: TopicAssociation,
    current_user: CurrentUser,
    card_repo: CardRepoDepends,
    deck_repo: DeckRepoDepends,
    topic_repo: TopicRepoDepends,
) -> None:
    """
    Associate a topic with a card.

    Args:
        card_id: Card identifier
        association: Topic association data
        current_user: Authenticated user
        card_repo: Card repository dependency
        deck_repo: Deck repository dependency
        topic_repo: Topic repository dependency

    Raises:
        HTTPException: If card or topic not found, or access denied
    """
    # Verify card exists
    card = card_repo.get(card_id)
    if not card:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Card not found",
        )

    # Verify user has access to the deck
    deck = deck_repo.get(card.deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Card not found",
        )

    # Verify topic exists
    topic = topic_repo.get(association.topic_id)
    if not topic:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Topic not found",
        )

    topic_repo.associate_card_topic(card_id, association.topic_id)


@router.delete("/cards/{card_id}/topics/{topic_id}", status_code=status.HTTP_204_NO_CONTENT)
async def dissociate_topic_from_card(
    card_id: str,
    topic_id: str,
    current_user: CurrentUser,
    card_repo: CardRepoDepends,
    deck_repo: DeckRepoDepends,
    topic_repo: TopicRepoDepends,
) -> None:
    """
    Remove topic association from a card.

    Args:
        card_id: Card identifier
        topic_id: Topic identifier
        current_user: Authenticated user
        card_repo: Card repository dependency
        deck_repo: Deck repository dependency
        topic_repo: Topic repository dependency

    Raises:
        HTTPException: If card or topic not found, or access denied
    """
    # Verify card exists
    card = card_repo.get(card_id)
    if not card:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Card not found",
        )

    # Verify user has access to the deck
    deck = deck_repo.get(card.deck_id, current_user.id)
    if not deck:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Card not found",
        )

    # Verify topic exists
    topic = topic_repo.get(topic_id)
    if not topic:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Topic not found",
        )

    topic_repo.dissociate_card_topic(card_id, topic_id)
