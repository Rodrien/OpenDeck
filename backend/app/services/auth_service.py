"""
Authentication Service

Handles JWT token generation, validation, and password hashing.
"""

from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext

from app.config import settings
from app.core.models import User
from app.core.interfaces import UserRepository

# Password hashing context
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class AuthService:
    """
    Authentication service for user management and JWT operations.

    This service is framework-agnostic and can be used with any HTTP adapter.
    """

    def __init__(self, user_repo: UserRepository) -> None:
        """
        Initialize authentication service.

        Args:
            user_repo: Repository for user data access
        """
        self.user_repo = user_repo

    @staticmethod
    def hash_password(password: str) -> str:
        """
        Hash a plain-text password using bcrypt.

        Args:
            password: Plain-text password

        Returns:
            Hashed password string
        """
        return pwd_context.hash(password)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        """
        Verify a password against its hash.

        Args:
            plain_password: Plain-text password to verify
            hashed_password: Hashed password to compare against

        Returns:
            True if password matches, False otherwise
        """
        return pwd_context.verify(plain_password, hashed_password)

    def create_access_token(self, user_id: str) -> str:
        """
        Create a JWT access token.

        Args:
            user_id: User identifier

        Returns:
            Encoded JWT token
        """
        expires_delta = timedelta(minutes=settings.access_token_expire_minutes)
        expire = datetime.utcnow() + expires_delta

        payload = {
            "sub": user_id,
            "exp": expire,
            "type": "access",
        }
        return jwt.encode(payload, settings.jwt_secret_key, algorithm=settings.jwt_algorithm)

    def create_refresh_token(self, user_id: str) -> str:
        """
        Create a JWT refresh token.

        Args:
            user_id: User identifier

        Returns:
            Encoded JWT refresh token
        """
        expires_delta = timedelta(days=settings.refresh_token_expire_days)
        expire = datetime.utcnow() + expires_delta

        payload = {
            "sub": user_id,
            "exp": expire,
            "type": "refresh",
        }
        return jwt.encode(payload, settings.jwt_secret_key, algorithm=settings.jwt_algorithm)

    def create_tokens(self, user: User) -> dict:
        """
        Create both access and refresh tokens for a user.

        Args:
            user: User to create tokens for

        Returns:
            Dictionary with access_token and refresh_token
        """
        return {
            "access_token": self.create_access_token(user.id),
            "refresh_token": self.create_refresh_token(user.id),
        }

    def verify_token(self, token: str, token_type: str = "access") -> Optional[str]:
        """
        Verify and decode a JWT token.

        Args:
            token: JWT token to verify
            token_type: Expected token type ("access" or "refresh")

        Returns:
            User ID if token is valid, None otherwise
        """
        try:
            payload = jwt.decode(
                token,
                settings.jwt_secret_key,
                algorithms=[settings.jwt_algorithm],
            )

            user_id: str = payload.get("sub")
            token_type_claim: str = payload.get("type")

            if not user_id or token_type_claim != token_type:
                return None

            return user_id

        except JWTError:
            return None

    def register_user(self, email: str, name: str, password: str) -> User:
        """
        Register a new user.

        Args:
            email: User email address
            name: User full name
            password: Plain-text password

        Returns:
            Created user

        Raises:
            ValueError: If email already exists
        """
        # Check if email already exists
        existing_user = self.user_repo.get_by_email(email)
        if existing_user:
            raise ValueError("Email already registered")

        # Create user with hashed password
        user = User(
            id="",  # Will be generated by repository
            email=email,
            name=name,
            password_hash=self.hash_password(password),
        )

        return self.user_repo.create(user)

    def authenticate_user(self, email: str, password: str) -> Optional[User]:
        """
        Authenticate a user with email and password.

        Args:
            email: User email address
            password: Plain-text password

        Returns:
            User if authentication successful, None otherwise
        """
        user = self.user_repo.get_by_email(email)
        if not user:
            return None

        if not self.verify_password(password, user.password_hash):
            return None

        return user

    def get_current_user(self, token: str) -> Optional[User]:
        """
        Get current user from access token.

        Args:
            token: JWT access token

        Returns:
            User if token is valid, None otherwise
        """
        user_id = self.verify_token(token, token_type="access")
        if not user_id:
            return None

        return self.user_repo.get(user_id)
